!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Complete	PartialSolution.h	/^enum { Complete, Ineficiente, Inviavel, Partial };$/;"	e	enum:__anon1
HEAP_H	Heap.h	9;"	d
Heap	Heap.cpp	/^Heap<T>::Heap() {$/;"	f	class:Heap
Heap	Heap.cpp	/^Heap<T>::Heap(const Heap& orig) {$/;"	f	class:Heap
Heap	Heap.h	/^class Heap {$/;"	c
INSTANCE_H	Instance.h	9;"	d
Ineficiente	PartialSolution.h	/^enum { Complete, Ineficiente, Inviavel, Partial };$/;"	e	enum:__anon1
Instance	Instance.cpp	/^Instance::Instance() {$/;"	f	class:Instance
Instance	Instance.cpp	/^Instance::Instance(const Instance& orig) {$/;"	f	class:Instance
Instance	Instance.h	/^class Instance {$/;"	c
Inviavel	PartialSolution.h	/^enum { Complete, Ineficiente, Inviavel, Partial };$/;"	e	enum:__anon1
NODE_H	Node.h	9;"	d
Node	Node.cpp	/^Node<T>::Node() {$/;"	f	class:Node
Node	Node.cpp	/^Node<T>::Node(T nodeSol_) {$/;"	f	class:Node
Node	Node.cpp	/^Node<T>::Node(const Node& orig) {$/;"	f	class:Node
Node	Node.h	/^class Node {$/;"	c
Partial	PartialSolution.h	/^enum { Complete, Ineficiente, Inviavel, Partial };$/;"	e	enum:__anon1
PartialSolution	PartialSolution.cpp	/^PartialSolution::PartialSolution () {$/;"	f	class:PartialSolution
PartialSolution	PartialSolution.cpp	/^PartialSolution::PartialSolution (const PartialSolution& orig) {$/;"	f	class:PartialSolution
PartialSolution	PartialSolution.h	/^class PartialSolution {$/;"	c
SET_H	Set.h	9;"	d
SOLUCAO_H	PartialSolution.h	9;"	d
Set	Set.cpp	/^Set::Set() {$/;"	f	class:Set
Set	Set.cpp	/^Set::Set(const Set& orig) {$/;"	f	class:Set
Set	Set.h	/^class Set {$/;"	c
atualizaLowerBound	PartialSolution.cpp	/^void PartialSolution::atualizaLowerBound ( vector < Set > sets ) {$/;"	f	class:PartialSolution
conj	PartialSolution.h	/^	std::set < int > conj;$/;"	m	class:PartialSolution
deleteHeap	Heap.cpp	/^void Heap<T>::deleteHeap(Node<T>* n) {$/;"	f	class:Heap
deleteTop	Heap.cpp	/^void Heap<T>::deleteTop() {$/;"	f	class:Heap
diff	main.cpp	/^set < int > diff ( set < int > A, set < int > B ) {$/;"	f
elements	Set.h	/^    std::vector<int> elements;$/;"	m	class:Set
empty	Heap.cpp	/^bool Heap<T>::empty() {$/;"	f	class:Heap
father	Node.h	/^    Node *father;$/;"	m	class:Node
feasibleSolution	Instance.cpp	/^bool Instance::feasibleSolution(int sol[]){$/;"	f	class:Instance
findLeaf	Heap.cpp	/^Node<T>* Heap<T>::findLeaf() {$/;"	f	class:Heap
head	Heap.h	/^    Node<T> *head;$/;"	m	class:Heap
heapfyBottomUp	Heap.cpp	/^void Heap<T>::heapfyBottomUp(Node<T>* n) {$/;"	f	class:Heap
heapfyTopDown	Heap.cpp	/^void Heap<T>::heapfyTopDown(Node<T>* n) {$/;"	f	class:Heap
inOrderPrint	Heap.cpp	/^void Heap<T>::inOrderPrint(Node<T>* n, int level) {$/;"	f	class:Heap
insert	Heap.cpp	/^void Heap<T>::insert(T p) {$/;"	f	class:Heap
k	Instance.h	/^    int k;$/;"	m	class:Instance
lchild	Node.h	/^    Node *lchild;$/;"	m	class:Node
lowerBound	PartialSolution.h	/^    long double lowerBound; \/\/A dual bound value$/;"	m	class:PartialSolution
main	main.cpp	/^int main () {$/;"	f
nodeSol	Node.h	/^    T nodeSol;$/;"	m	class:Node
numElemUnion	main.cpp	/^int numElemUnion (vector < int > a, vector < int > b ) {$/;"	f
numberElements	Instance.h	/^    int numberElements; \/\/Number of elements to be covered from 1...numberElements$/;"	m	class:Instance
numberSets	Instance.h	/^    int numberSets; \/\/Number of sets of the instance$/;"	m	class:Instance
operator !=	PartialSolution.cpp	/^bool PartialSolution::operator!=(const PartialSolution &p) const {$/;"	f	class:PartialSolution
operator <	PartialSolution.cpp	/^bool PartialSolution::operator<(const PartialSolution &p) const {$/;"	f	class:PartialSolution
operator <<	PartialSolution.cpp	/^std::ostream & operator<<(std::ostream & os, const PartialSolution &p) {$/;"	f
operator <=	PartialSolution.cpp	/^bool PartialSolution::operator<=(const PartialSolution &p) const {$/;"	f	class:PartialSolution
operator =	PartialSolution.cpp	/^PartialSolution& PartialSolution::operator=(const PartialSolution &orig) {$/;"	f	class:PartialSolution
operator ==	PartialSolution.cpp	/^bool PartialSolution::operator==(const PartialSolution &p) const {$/;"	f	class:PartialSolution
operator >	PartialSolution.cpp	/^bool PartialSolution::operator>(const PartialSolution &p) const {$/;"	f	class:PartialSolution
operator >=	PartialSolution.cpp	/^bool PartialSolution::operator>=(const PartialSolution &p) const {$/;"	f	class:PartialSolution
print	Heap.cpp	/^void Heap<T>::print() {$/;"	f	class:Heap
printInstance	Instance.cpp	/^void Instance::printInstance(){$/;"	f	class:Instance
randDouble	Heap.cpp	/^double Heap<T>::randDouble() {$/;"	f	class:Heap
rchild	Node.h	/^    Node *rchild;$/;"	m	class:Node
readInstance	Instance.cpp	/^void Instance::readInstance(){$/;"	f	class:Instance
sets	Instance.h	/^    std::vector<Set> sets; \/\/The sets of the instance$/;"	m	class:Instance
showLB	PartialSolution.cpp	/^long double PartialSolution::showLB () {$/;"	f	class:PartialSolution
size	Set.h	/^    int size;$/;"	m	class:Set
status	PartialSolution.h	/^	int status;$/;"	m	class:PartialSolution
top	Heap.cpp	/^T Heap<T>::top() {$/;"	f	class:Heap
upperBound	PartialSolution.h	/^    long double upperBound; \/\/A primal bound value$/;"	m	class:PartialSolution
value	PartialSolution.h	/^    long double value; \/\/The value of the partial selected sets$/;"	m	class:PartialSolution
value	Set.h	/^    long double value;$/;"	m	class:Set
~Heap	Heap.cpp	/^Heap<T>::~Heap() {$/;"	f	class:Heap
~Instance	Instance.cpp	/^Instance::~Instance() {$/;"	f	class:Instance
~Node	Node.cpp	/^Node<T>::~Node() {$/;"	f	class:Node
~PartialSolution	PartialSolution.cpp	/^PartialSolution::~PartialSolution() {$/;"	f	class:PartialSolution
~Set	Set.cpp	/^Set::~Set() {$/;"	f	class:Set
